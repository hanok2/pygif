#!/usr/bin/python3

import array
import configparser
import gif
import itertools
import sys

def get_color (color_table, index):
    if index < len (color_table):
        (red, green, blue) = color_table[index]
        return (red, green, blue, 255)
    else:
        return (0, 0, 0, 255)

def set_pixel (reader, pixels, x, y, color):
    offset = (y * reader.width + x) * 4
    (red, green, blue, alpha) = color
    pixels[offset + 0] = red
    pixels[offset + 1] = green
    pixels[offset + 2] = blue
    pixels[offset + 3] = alpha

def get_pixel (reader, pixels, x, y):
    offset = (y * reader.width + x) * 4
    return (pixels[offset + 0], pixels[offset + 1], pixels[offset + 2], pixels[offset + 3])

def render_block (reader, pixels, block, transparent_color):
    i = 0
    block_pixels = block.get_pixels ()
    if len (block.color_table) > 0:
        color_table = block.color_table
    else:
        color_table = reader.color_table
    if block.interlace:
        top = block.top
        bottom = block.top + block.height
        row_iter = itertools.chain (range (top, bottom, 8), range (top + 4, bottom, 8), range (top + 2, bottom, 4), range (top + 1, bottom, 2))
    else:
        row_iter = range (block.top, block.top + block.height)
    for y in row_iter:
        for x in range (block.left, block.left + block.width):
            if i >= len (block_pixels):
                return
            index = block_pixels[i]
            i += 1
            if 0 <= x < reader.width and 0 <= y < reader.height:
                if index == transparent_color:
                    color = (0, 0, 0, 0)
                else:
                    color = get_color (color_table, index)
                set_pixel (reader, pixels, x, y, color)

def dispose_block (reader, pixels, block, method, previous_pixels):
    if method == gif.DisposalMethod.KEEP:
        pass
    elif method == gif.DisposalMethod.RESTORE_BACKGROUND:
        color = (0, 0, 0, 0)
        for y in range (block.top, block.top + block.height):
            for x in range (block.left, block.left + block.width):
                if 0 <= x < reader.width and 0 <= y < reader.height:
                    set_pixel (reader, pixels, x, y, color)
    elif method == gif.DisposalMethod.RESTORE_PREVIOUS:
        for y in range (block.top, block.top + block.height):
            for x in range (block.left, block.left + block.width):
                if 0 <= x < reader.width and 0 <= y < reader.height:
                    color = get_pixel (reader, previous_pixels, x, y)
                    set_pixel (reader, pixels, x, y, color)
        pass # FIXME

def render (reader):
    # Fill background
    pixels = array.array ('B')
    color = get_color (reader.color_table, reader.background_color)
    for y in range (reader.height):
        for x in range (reader.width):
            (red, green, blue, alpha) = color
            pixels.append (red)
            pixels.append (green)
            pixels.append (blue)
            pixels.append (alpha)

    # Write images onto background
    disposal_method = gif.DisposalMethod.NONE
    transparent_color = None
    last_block = None
    previous_pixels = pixels[:]
    for block in reader.blocks:
        if isinstance (block, gif.GraphicControlExtension):
            disposal_method = block.disposal_method
            if block.has_transparent:
                transparent_color = block.transparent_color
        elif isinstance (block, gif.Image):
            if last_block is not None:
                (m, b) = last_block
                dispose_block (reader, pixels, b, m, previous_pixels)
            render_block (reader, pixels, block, transparent_color)
            if disposal_method != gif.DisposalMethod.RESTORE_PREVIOUS:
                previous_pixels = pixels[:]
            last_block = (disposal_method, block)
            disposal_method = gif.DisposalMethod.NONE
            transparent_color = None

    return (reader.width, reader.height, pixels)

def compare_to_reference_frame (reader, pixels, filename):
    r_pixels = open (filename, 'rb').read ()
    for y in range (reader.height):
        for x in range (reader.width):
            color = get_pixel (reader, pixels, x, y)
            r_color = get_pixel (reader, r_pixels, x, y)
            if color[3] == r_color[3] == 0:
                pass
            elif color != r_color:
                print ('  Pixel mismatch at %d,%d! Got %s, expected %s' % (x, y, color, r_color))
                return False
    return True;

def run_test (name):
    print ('Running %s' % name)

    config = configparser.ConfigParser ()
    config_filename = 'test-suite/%s.conf' % name
    config.read (config_filename);
    if not config.has_section ('config'):
        print ('  Test config %s does not exist / invalid' % config_filename)
        return False

    c = config['config']
    input_filename = c['input']
    frames = []
    frame_names = c['frames'].split (',')
    for frame_name in frame_names:
        if frame_name != '':
            frames.append (config[frame_name])

    print ('  Loading image %s' % input_filename)
    reader = gif.Reader ()
    data = open ('test-suite/%s' % input_filename, 'rb').read ()
    reader.feed (data)

    xmp_filename = c['xmp-data'].strip ()
    xmp_data = ''
    if xmp_filename != '':
        xmp_data = open ('test-suite/%s' % xmp_filename).read ()
    expected_data = ''
    for block in reader.blocks:
        if isinstance (block, gif.XMPDataExtension):
            expected_data = block.get_metadata ()
    if xmp_data != expected_data:
        print ('  XMP Data mismatch!')
        print ('  Got:')
        print (xmp_data)
        print ('  Expected:')
        print (expected_data)
        return False

    icc_filename = c['color-profile'].strip ()
    icc_data = b''
    if icc_filename != '':
        icc_data = open ('test-suite/%s' % icc_filename, 'rb').read ()
    expected_data = b''
    for block in reader.blocks:
        if isinstance (block, gif.ICCColorProfileExtension):
            expected_data = block.get_icc_profile ()
    if icc_data != expected_data:
        print ('  ICC Color Profile mismatch!')
        print ('  Got     : %s' % repr (icc_data))
        print ('  Expected: %s' % repr (expected_data))
        return False

    # Skip test that uses too much memory
    if name == 'max-size':
        return True

    if len (frames) == 0:
        return True

    (width, height, pixels) = render (reader)

    frame = frames[-1]
    reference_filename = 'test-suite/%s' % frame['pixels']
    expected_width = int (frame['width'])
    expected_height = int (frame['height'])
    if (expected_width, expected_height) != (reader.width, reader.height):
        print ('  Size mismatch! Got %dx%d, expected %dx%d' % (reader.width, reader.height, expected_width, expected_height))
        return False

    print ('  Comparing to %s' % reference_filename)
    return compare_to_reference_frame (reader, pixels, reference_filename)

if len (sys.argv) > 1:
    tests = sys.argv[1:]
else:
    lines = open ('test-suite/TESTS').readlines ()
    tests = []
    for line in lines:
        name = line.strip ()
        if name != '':
            tests.append (name)

successes = []
failures = []
for name in tests:
    if run_test (name):
        print ('  PASS')
        successes.append (name)
    else:
        print ('  FAIL')
        failures.append (name)
print ('------------------')
print ('%d/%d tests passed' % (len (successes), len (successes) + len (failures)))
if len (failures) > 0:
    print ('Failures: %s' % ', '.join (failures))
    print ('FAIL')
else:
    print ('PASS')
